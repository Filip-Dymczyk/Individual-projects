import tkinter as tk
from typing import Optional


# Class representing user data who is currently using the program: login, password and an account:
class User:
    def __init__(self) -> None:
        self.__login: Optional[str] = None
        self.__password: Optional[str] = None
        self.account: Account = Account()

    def set_login(self, login: str) -> None:
        self.__login = login

    def set_password(self, password: str) -> None:
        self.__password = password

    def get_login(self) -> str:
        return self.__login

    def get_password(self) -> str:
        return self.__password


# Class representing a database, probably file reader and writer at first; in later versions maybe a regular database:
class DataBase:
    def __init__(self) -> None:
        # Keeping track of information that may be used to speed-up later processes of the application like:
        # number of line in which we have data related to the user that is currently logged and his account balance.
        self.line_nr = None
        self.account_balance = None

        self.__file = open("C:\\Users\\User\\Desktop\\Python_projects\\python_projects\\BankAccount\\data.txt", "r+")

    # Checking if login exists in the file - we don't allow same logins:
    def check_login_in_file(self, login: str) -> bool:
        return login in self.__file.read()

    # Checking (during login) if the login entered is present and if it matches the password in the same
    # line of the file.
    # True means that login data are viable, False says otherwise.
    def check_login_password(self, login: str, password) -> bool:
        if self.check_login_in_file(login):
            # We get a tab of all lines and index of every line:
            for i, line in enumerate(self.__file.readlines()):
                # if given login is in the line:
                if login in line:
                    # We split it so that there are no spaces - we get an array:
                    line_split = line.split()
                    # Second element is password:
                    password_from_file = line_split[1]

                    # Third element is balance which we save:
                    self.account_balance = float(line_split[2])
                    # We also get the line nr in which we have useful information:
                    self.line_nr = i

                    return password_from_file == password
        return False

    # Writing data to file after registration is finished. Remembers client's account balance.
    def write_data_to_file(self, login: str, password: str) -> None:
        line = f"{login} {password} {0}\n"
        self.__file.write(line)

        # It's now the last line - newly added:
        self.line_nr = len(self.__file.readlines()) - 1

        # Balance = 0:
        self.account_balance = 0

    # Getting balance related to particular User:
    def get_balance(self) -> float:
        return self.account_balance

    def


# Class representing account details:
class Account:
    def __init__(self) -> None:
        pass


# Interface handling all the windows appearing throughout the program:
class Interface:
    def __init__(self) -> None:
        # Creating Tk-windows:
        self.__log_in_window: Optional[tk.Tk] = None
        self.__register_window: Optional[tk.Tk] = None
        self.__account_window: Optional[tk.Tk] = None

        # Creating DataBase object to handle flow of information:
        self.__data_base: DataBase = DataBase()

        # Creating associated user:
        self.__user: User = User()

    # Helper checking password or login viability:
    def __check_viability(self, l_p: str) -> bool:
        return 4 < len(l_p) < 10 and l_p.isalnum()

    # Functions handling buttons hovering:
    def __on_hover(self, event: tk.Event, button_id: int) -> None:
        widget = event.widget
        # Confirm button and registration button form log-in, confirm and from registration:
        if button_id in [1, 2, 4]:
            widget.config(bg="green")
        # Return button from registration:
        elif button_id in [5]:
            widget.config(bg="yellow")
        # Close button:
        elif button_id in [3, 6]:
            widget.config(bg="red")

    def __on_hover_leave(self, event: tk.Event) -> None:
        widget = event.widget
        widget.configure(bg="white")

    # Help functions responsible for handling events generated by pressing Enter on entries:
    def __on_enter_pressed_login(self, event: tk.Event) -> None:
        entry = event.widget
        login = entry.get()
        # Login entries:
        if self.__check_viability(login) and self.__data_base.check_login_in_file(login):
            entry.config(bg="green")
        else:
            entry.config(bg="red")

    def __on_enter_pressed_password(self, event: tk.Event) -> None:
        entry = event.widget
        password = entry.get()
        # Password entries:
        if self.__check_viability(password):
            entry.config(bg="green")
        else:
            entry.config(bg="red")

    # Log-in window configuration:
    def __configure_window_log_in(self) -> None:

        # Initializing log_in window:
        self.__log_in_window = tk.Tk()
        self.__log_in_window.title("Log in")

        # Toggling red cross in the top right corner to terminating the app:
        self.__log_in_window.protocol("WM_DELETE_WINDOW", self.__close_all_cross)

        # Submitting login and password via confirm - initializing User:
        def submit_login_password() -> None:
            login = entry_login.get()
            password = entry_password.get()

            # If login and password are viable and they are in data_base related to each-other then the login is successful:
            if self.__check_viability(login) and self.__check_viability(password) and \
                    self.__data_base.check_login_in_file(login) and \
                    self.__data_base.check_login_password(login, password):

                self.__user.set_login(login)
                self.__user.set_password(password)

                # Add: getting account balance for data_base and setting users Account with it:

                # Move to another window:
                self.__account_management_window()

        # Setting pad on x- and y-axis:
        padx = 5
        pady = 5

        # Labels:
        label1 = tk.Label(self.__log_in_window, text="Login", font="Calibri 12")
        label2 = tk.Label(self.__log_in_window, text="Password", font="Calibri 12")
        label3 = tk.Label(self.__log_in_window, text="Don't have an account yet?", font="Calibri 10 underline")

        # Entry fields to enter login and password:
        entry_login = tk.Entry(self.__log_in_window, width=35)
        entry_password = tk.Entry(self.__log_in_window, show="*", width=35)

        # Binding entry fields to trigger checking data entered in the fields by Enter:
        entry_login.bind("<Return>", self.__on_enter_pressed_login)
        entry_password.bind("<Return>", self.__on_enter_pressed_password)

        # Buttons for: registration, data confirmation and closing the window:
        registration_button = tk.Button(self.__log_in_window, text="Click here to register",
                                        command=self.__open_registration_window, font="Calibri 10 bold")
        confirm_button = tk.Button(self.__log_in_window, text="Confirm", command=submit_login_password,
                                   font="Calibri 10")
        leave_button = tk.Button(self.__log_in_window, text="Leave",
                                 command=lambda leave_button_id=1: self.__terminate(leave_button_id), font="Calibri 10")

        # Introducing new events on entering and leaving confirm, close and registration buttons area:
        confirm_button.bind("<Enter>", lambda event, button_id=1: self.__on_hover(event, button_id))
        registration_button.bind("<Enter>", lambda event, button_id=2: self.__on_hover(event, button_id))
        leave_button.bind("<Enter>", lambda event, button_id=3: self.__on_hover(event, button_id))

        confirm_button.bind("<Leave>", self.__on_hover_leave)
        leave_button.bind("<Leave>", self.__on_hover_leave)
        registration_button.bind("<Leave>", self.__on_hover_leave)

        # Packing created widgets into window:
        label1.pack()
        entry_login.pack(pady=pady)
        label2.pack()
        entry_password.pack(pady=pady)
        confirm_button.pack(pady=3 * pady)
        label3.pack(pady=pady)
        registration_button.pack()
        leave_button.pack(padx=2 * padx, pady=3 * pady, side="right")

    # Registration window:
    def __open_registration_window(self) -> None:

        # Withdrawing log_in window from view:
        self.__log_in_window.withdraw()

        # Handling enter pressed on re-password:
        def on_enter_pressed_re_password(event: tk.Event) -> None:
            widget = event.widget
            re_password = widget.get()
            if self.__check_viability(re_password) and re_password == entry_password.get():
                widget.configure(bg="green")
            else:
                widget.configure(bg="red")

        def create_an_account() -> None:

            # Get all entries from window:
            login = entry_login.get()
            password = entry_password.get()
            re_password = entry_re_password.get()

            if self.__check_viability(login) and self.__check_viability(password) and self.__check_viability(
                    re_password):
                # Check passwords identity:
                if password == re_password:
                    # Update the DataBase - enter new client data:

                    # Go trough transition window:
                    self.__transtition_window_account_created()

        # Initializing registration window:
        self.__register_window = tk.Tk()
        self.__register_window.title("Registration")

        # Toggling red cross in the top right corner to terminating the app:
        self.__register_window.protocol("WM_DELETE_WINDOW", self.__close_all_cross)

        # Setting pad on x- and y-axis:
        padx = 5
        pady = 5

        # Labels:
        label1 = tk.Label(self.__register_window, text="Login", font="Calibri 12")
        label2 = tk.Label(self.__register_window, text="Password", font="Calibri 12")
        label3 = tk.Label(self.__register_window, text="Enter your password again", font="Calibri 12")
        # label4 = tk.Label(self.__register_window, text="Enter your email", font="Calibri 12")

        # Entry fields to enter login and password and email:
        entry_login = tk.Entry(self.__register_window, width=30)
        entry_password = tk.Entry(self.__register_window, show="*", width=30)
        entry_re_password = tk.Entry(self.__register_window, show="*", width=30)
        # entry_email = tk.Entry(self.__register_window, width=30)

        # Binding fields on enter trigger:
        entry_login.bind("<Return>", self.__on_enter_pressed_login)
        entry_password.bind("<Return>", self.__on_enter_pressed_password)
        entry_re_password.bind("<Return>", on_enter_pressed_re_password)

        # Confirm, close, return to log_in buttons:
        confirm_button = tk.Button(self.__register_window, text="Confirm", font="Calibri 10", command=create_an_account)
        return_button = tk.Button(self.__register_window, text="Return to log-in", font="Calibri 10",
                                  command=self.__return_to_log_in)

        # On hover:
        confirm_button.bind("<Enter>", lambda event, button_id=4: self.__on_hover(event, button_id))
        return_button.bind("<Enter>", lambda event, button_id=5: self.__on_hover(event, button_id))

        confirm_button.bind("<Leave>", self.__on_hover_leave)
        return_button.bind("<Leave>", self.__on_hover_leave)

        # Packing:
        label1.pack()
        entry_login.pack(pady=2 * pady)
        label2.pack()
        entry_password.pack(pady=2 * pady)
        label3.pack()
        entry_re_password.pack(pady=2 * pady)
        # label4.pack()
        # entry_email.pack(pady=2*pady)
        confirm_button.pack(pady=3 * pady)
        return_button.pack(side="bottom", pady=pady)

    # Little window informing about positive account creation:
    def __transtition_window_account_created(self) -> None:
        pass

    def __account_management_window(self) -> None:
        pass

    # Getting user login - for test:
    def get_user_login(self) -> str:
        return self.__user.get_login()

    # Returning to login window - withdrawing registration and showing login:
    def __return_to_log_in(self) -> None:
        if self.__register_window.winfo_exists():
            self.__register_window.withdraw()
        if self.__log_in_window.winfo_exists():
            self.__log_in_window.iconify()

    # Terminating the whole program:
    def __terminate(self, close_button_nr: int) -> None:
        # Close button from log_in:
        if close_button_nr == 1:
            if self.__register_window:
                self.__register_window.destroy()
            self.__log_in_window.quit()

    # Closing the app with the use of a red cross:
    def __close_all_cross(self) -> None:
        self.__log_in_window.quit()

    # Activating program:
    def activate(self) -> None:
        self.__configure_window_log_in()
        self.__log_in_window.mainloop()
